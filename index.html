<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°—ä½“åˆ†å­é‹å‹•è«–3Då¯è¦–åŒ–</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            touch-action: none; /* ã‚¿ãƒƒãƒæ“ä½œã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’ç„¡åŠ¹åŒ– */
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            font-size: 14px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
            max-width: 95%; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã®è¡¨ç¤ºã‚’è€ƒæ…® */
            margin: 0 auto;
            display: block;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            width: 320px;
        }
        #distribution-canvas {
            width: 100%;
            height: 180px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }
        .stats {
            margin-top: 15px;
            font-size: 13px;
            line-height: 1.6;
        }
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: inline-block;
            margin-right: 15px;
        }
        .color-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã®ãƒœã‚¿ãƒ³ */
        #mobile-menu-btn {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            font-size: 20px;
            width: 40px;
            height: 40px;
        }
        
        #mobile-info-btn {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            font-size: 20px;
            width: 40px;
            height: 40px;
        }
        
        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
        @media (max-width: 768px) {
            #mobile-menu-btn, #mobile-info-btn {
                display: block;
            }
            
            #controls, #info-panel {
                position: fixed;
                width: 90%;
                max-width: 400px;
                top: 60px;
                transform: translateX(-110%);
                transition: transform 0.3s ease;
                z-index: 999;
                max-height: 80vh;
                padding: 15px 20px; /* å·¦å³ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å°‘ã—å¢—ã‚„ã™ */
            }
            
            #controls {
                left: 5%;
            }
            
            #info-panel {
                right: auto;
                left: 5%;
                transform: translateX(110vw);
            }
            
            #controls.show {
                transform: translateX(0);
            }
            
            #info-panel.show {
                transform: translateX(0);
            }
            
            button {
                padding: 10px 16px;
                font-size: 16px;
            }
            
            .control-group label {
                font-size: 16px;
            }
            
            h3 {
                font-size: 18px;
            }
            
            .stats {
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            #controls, #info-panel {
                width: 95%;
                font-size: 14px;
            }
            
            #distribution-canvas {
                height: 150px;
            }
        }
        
        /* ç”»é¢ãŒæ¨ªå‘ãã®å ´åˆ */
        @media (max-width: 768px) and (orientation: landscape) {
            #controls, #info-panel {
                max-height: 90vh;
                top: 50px;
            }
        }
    </style>
</head>
<body>
    <button id="mobile-menu-btn">â˜°</button>
    <button id="mobile-info-btn">ğŸ“Š</button>
    
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h3>æ°—ä½“åˆ†å­é‹å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h3>
        
        <div class="control-group">
            <label>ç²’å­æ•°: <span id="particle-count">50</span></label>
            <input type="range" id="particles" min="1" max="500" value="50" step="1">
        </div>
        
        <div class="control-group">
            <label>æ¸©åº¦ (K): <span id="temperature-value">300</span></label>
            <input type="range" id="temperature" min="10" max="5000" value="300" step="10">
        </div>
        
        <div class="control-group">
            <label>æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«: <span id="time-scale-value">1</span></label>
            <input type="range" id="time-scale" min="0" max="10" value="1" step="0.1">
        </div>
        
        <div class="control-group">
            <button id="reset-btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button id="pause-btn">ä¸€æ™‚åœæ­¢</button>
        </div>
        
        <div class="control-group">
            <label>åŠ›ã®å¯è¦–åŒ–:</label>
            <label>
                <input type="checkbox" id="show-wall-forces"> å£ã¸ã®è¡çªåŠ›
            </label>
            <label>
                <input type="checkbox" id="show-pressure-vectors"> é¢ã”ã¨ã®åœ§åŠ›
            </label>
        </div>
        
        <div class="legend">
            <h4>é€Ÿåº¦ã«ã‚ˆã‚‹è‰²åˆ†ã‘:</h4>
            <div class="legend-item">
                <span class="color-box" style="background: #0066ff;"></span>ä½é€Ÿ
            </div>
            <div class="legend-item">
                <span class="color-box" style="background: #00ff00;"></span>ä¸­é€Ÿ
            </div>
            <div class="legend-item">
                <span class="color-box" style="background: #ff0000;"></span>é«˜é€Ÿ
            </div>
        </div>
    </div>
    
    <div id="info-panel">
        <h3>ãƒã‚¯ã‚¹ã‚¦ã‚§ãƒ«ãƒ»ãƒœãƒ«ãƒ„ãƒãƒ³åˆ†å¸ƒ</h3>
        <canvas id="distribution-canvas"></canvas>
        
        <div class="stats">
            <div>å¹³å‡é€Ÿåº¦: <span id="avg-speed">0</span> m/s</div>
            <div>æœ€ç¢ºé€Ÿåº¦: <span id="most-probable-speed">0</span> m/s</div>
            <div>å¹³å‡é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼: <span id="avg-energy">0</span> Ã— 10â»Â²Â¹ J</div>
            <div>ç²’å­å¯†åº¦: <span id="density">0</span> å€‹/nmÂ³</div>
            <div>ï¼ˆç®±ã®ã‚µã‚¤ã‚º: 10 = 10 nmï¼‰</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å®šæ•°
        const k_B = 1.380649e-23; // ãƒœãƒ«ãƒ„ãƒãƒ³å®šæ•°
        const m_gas = 4.65e-26; // çª’ç´ åˆ†å­è³ªé‡
        
        // å¤‰æ•°
        let scene, camera, renderer;
        let particles = [];
        let boxSize = 10;
        let temperature = 300;
        let particleCount = 50;
        let timeScale = 1;
        let isPaused = false;
        let animationId;
        
        // åŠ›ã®å¯è¦–åŒ–ç”¨
        let wallForces = [];
        let wallImpacts = [];
        let pressureVectors = [];
        let showWallForces = false;
        let showPressureVectors = false;
        let wallImpulses = {
            '+x': 0, '-x': 0,
            '+y': 0, '-y': 0,
            '+z': 0, '-z': 0
        };
        
        // åˆæœŸåŒ–
        function init() {
            // ã‚·ãƒ¼ãƒ³
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // ã‚«ãƒ¡ãƒ©
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            
            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ãƒ©ã‚¤ãƒˆ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // ç®±ã‚’ä½œæˆ
            createBox();
            
            // ç²’å­ã‚’ä½œæˆ
            createParticles();
            
            // ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            setupMouseControls();
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            setupEventListeners();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animate();
        }
        
        function createBox() {
            // ç®±ã®æ 
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x00ff00 })
            );
            scene.add(line);
            
            // åŠé€æ˜ã®å£
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0x004400,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const box = new THREE.Mesh(geometry, wallMaterial);
            scene.add(box);
        }
        
        function createParticles() {
            // æ—¢å­˜ã®ç²’å­ã‚’å‰Šé™¤
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            
            // åŠ›ã®å¯è¦–åŒ–ã‚‚ãƒªã‚»ãƒƒãƒˆ
            wallForces.forEach(force => {
                scene.remove(force.line);
                scene.remove(force.cone);
            });
            wallForces = [];
            wallImpacts.forEach(impact => scene.remove(impact.mesh));
            wallImpacts = [];
            pressureVectors.forEach(vector => scene.remove(vector));
            pressureVectors = [];
            Object.keys(wallImpulses).forEach(key => {
                wallImpulses[key] = 0;
            });
            
            // çƒã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆå…±æœ‰ï¼‰
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            
            for (let i = 0; i < particleCount; i++) {
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0x000000,
                    emissiveIntensity: 0.5
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®
                mesh.position.set(
                    (Math.random() - 0.5) * (boxSize - 0.4),
                    (Math.random() - 0.5) * (boxSize - 0.4),
                    (Math.random() - 0.5) * (boxSize - 0.4)
                );
                
                // ãƒã‚¯ã‚¹ã‚¦ã‚§ãƒ«ãƒ»ãƒœãƒ«ãƒ„ãƒãƒ³åˆ†å¸ƒã«å¾“ã†é€Ÿåº¦
                const velocity = generateVelocity();
                
                particles.push({
                    mesh: mesh,
                    velocity: velocity
                });
                
                scene.add(mesh);
            }
        }
        
        function generateVelocity() {
            // Box-Mullerå¤‰æ›ã§æ­£è¦åˆ†å¸ƒã‚’ç”Ÿæˆ
            const sigma = Math.sqrt(k_B * temperature / m_gas);
            
            function gaussian() {
                const u1 = Math.random();
                const u2 = Math.random();
                return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            }
            
            return new THREE.Vector3(
                gaussian() * sigma * 0.001,
                gaussian() * sigma * 0.001,
                gaussian() * sigma * 0.001
            );
        }
        
        function updateParticles(deltaTime) {
            if (isPaused || timeScale === 0) return;
            
            const dt = deltaTime * timeScale;
            const halfBox = boxSize / 2;
            
            particles.forEach((particle, i) => {
                // ä½ç½®ã‚’æ›´æ–°
                particle.mesh.position.add(
                    particle.velocity.clone().multiplyScalar(dt)
                );
                
                // å£ã¨ã®è¡çª
                ['x', 'y', 'z'].forEach(axis => {
                    if (Math.abs(particle.mesh.position[axis]) > halfBox - 0.15) {
                        const oldVel = particle.velocity[axis];
                        particle.velocity[axis] *= -1;
                        particle.mesh.position[axis] = 
                            Math.sign(particle.mesh.position[axis]) * (halfBox - 0.15);
                        
                        // å£ã¸ã®åŠ›ã‚’è¨˜éŒ²
                        if (showWallForces || showPressureVectors) {
                            const speed = Math.abs(oldVel);
                            const impulse = 2 * m_gas * speed;
                            const wallNormal = new THREE.Vector3(0, 0, 0);
                            wallNormal[axis] = -Math.sign(particle.mesh.position[axis]);
                            
                            // å€‹åˆ¥ã®è¡çªåŠ›ã®å¯è¦–åŒ–
                            if (showWallForces) {
                                const impactPos = particle.mesh.position.clone();
                                impactPos[axis] = Math.sign(impactPos[axis]) * halfBox;
                                
                                addWallForce(impactPos, wallNormal, impulse);
                                addWallImpact(impactPos, axis);
                            }
                            
                            // é¢ã”ã¨ã®åŠ›ç©ã‚’ç´¯ç©
                            const wallKey = (particle.mesh.position[axis] > 0 ? '+' : '-') + axis;
                            wallImpulses[wallKey] += impulse;
                        }
                    }
                });
                
                // ä»–ã®ç²’å­ã¨ã®è¡çªï¼ˆç°¡æ˜“ç‰ˆï¼‰
                for (let j = i + 1; j < particles.length; j++) {
                    const other = particles[j];
                    const distance = particle.mesh.position.distanceTo(other.mesh.position);
                    
                    if (distance < 0.3) {
                        // è¡çªå‡¦ç†
                        const normal = particle.mesh.position.clone()
                            .sub(other.mesh.position).normalize();
                        
                        const relVel = particle.velocity.clone().sub(other.velocity);
                        const speed = relVel.dot(normal);
                        
                        if (speed > 0) continue;
                        
                        particle.velocity.sub(normal.clone().multiplyScalar(speed));
                        other.velocity.add(normal.clone().multiplyScalar(speed));
                    }
                }
                
                // é€Ÿåº¦ã«å¿œã˜ã¦è‰²ã‚’å¤‰æ›´
                updateParticleColor(particle);
            });
            
            // åŠ›ã®å¯è¦–åŒ–ã‚’æ›´æ–°
            updateForceVisualizations(dt);
        }
        
        function addWallForce(position, normal, impulse) {
            // çŸ¢å°ã®åŸç‚¹ã‚’å£ã®è¡¨é¢ã«è¨­å®š
            const origin = position.clone();
            // çŸ¢å°ã®æ–¹å‘ã¯å£ã®å¤–å´ã¸ï¼ˆæ³•ç·šã®åå¯¾æ–¹å‘ = å¤–å‘ãï¼‰
            const direction = normal.clone().negate();
            
            // åŠ›ã®å¤§ãã•ã«å¿œã˜ãŸé•·ã•
            // é€Ÿåº¦ã«åŸºã¥ã„ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ï¼ˆã‚ˆã‚Šç¾å®Ÿçš„ãªç¯„å›²ã«ï¼‰
            const speed = Math.sqrt(impulse / (2 * m_gas)) * 1000; // m/s
            const lengthRatio = Math.min(speed / 1500, 1); // 1500 m/sã‚’åŸºæº–
            const length = 0.5 + lengthRatio * 2.5; // 0.5ï½3.0ã®ç¯„å›²
            
            // è‰²ã®è¨ˆç®—ï¼ˆé€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã§ç²’å­ã¨åŒã˜è‰²åˆ†ã‘ï¼‰
            const color = getSpeedBasedColor(speed);
            
            // ç·šã‚’æç”»
            const geometry = new THREE.BufferGeometry();
            const points = [];
            points.push(origin);
            points.push(origin.clone().add(direction.clone().multiplyScalar(length)));
            geometry.setFromPoints(points);
            
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 3,
                transparent: true,
                opacity: 1.0
            });
            const line = new THREE.Line(geometry, lineMaterial);
            
            // çŸ¢å°ã®å…ˆç«¯ã«ã‚³ãƒ¼ãƒ³ã‚’è¿½åŠ 
            const coneSize = 0.15 + lengthRatio * 0.15; // ã‚µã‚¤ã‚ºã‚‚èª¿æ•´
            const coneGeometry = new THREE.ConeGeometry(coneSize, coneSize * 2.5, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 1.0
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            
            // ã‚³ãƒ¼ãƒ³ã®ä½ç½®ã‚’è¨­å®š
            const conePosition = origin.clone().add(direction.clone().multiplyScalar(length - coneSize * 1.25));
            cone.position.copy(conePosition);
            
            // ã‚³ãƒ¼ãƒ³ã®å‘ãã‚’è¨­å®šï¼ˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã«å‘ã‹ã£ã¦ï¼‰
            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(up, direction);
            cone.setRotationFromQuaternion(quaternion);
            
            scene.add(line);
            scene.add(cone);
            
            wallForces.push({
                line: line,
                cone: cone,
                lifetime: 2.0
            });
        }
        
        // é€Ÿåº¦ã«åŸºã¥ã„ã¦è‰²ã‚’è¿”ã™é–¢æ•°ï¼ˆç²’å­ã¨åŒã˜è‰²åˆ†ã‘ï¼‰
        function getSpeedBasedColor(speed) {
            // è‰²åˆ†ã‘ã®ç¯„å›²ã‚’èª¿æ•´ã—ã¦ã€ã‚ˆã‚Šå¹…åºƒã„è‰²ãŒå‡ºã‚‹ã‚ˆã†ã«
            // 0-750 m/s: é’â†’ç·‘
            // 750-1500 m/s: ç·‘â†’èµ¤
            const ratio = Math.min(speed / 1500, 1);
            
            let r, g, b;
            if (ratio < 0.5) {
                // é’â†’ç·‘
                r = 0;
                g = Math.floor(ratio * 2 * 255);
                b = Math.floor((1 - ratio * 2) * 255);
            } else {
                // ç·‘â†’èµ¤
                r = Math.floor((ratio - 0.5) * 2 * 255);
                g = Math.floor((1 - (ratio - 0.5) * 2) * 255);
                b = 0;
            }
            
            return (r << 16) | (g << 8) | b;
        }
        
        function addWallImpact(position, axis) {
            // è¡çªç‚¹ã®å††å½¢è¡¨ç¤º
            const geometry = new THREE.CircleGeometry(0.3, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(geometry, material);
            
            // å††ã‚’å£ã«é…ç½®
            circle.position.copy(position);
            if (axis === 'x') circle.rotation.y = Math.PI / 2;
            else if (axis === 'y') circle.rotation.x = Math.PI / 2;
            
            scene.add(circle);
            wallImpacts.push({
                mesh: circle,
                lifetime: 2.0
            });
        }
        
        function updateForceVisualizations(dt) {
            // å£ã¸ã®åŠ›ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            wallForces = wallForces.filter(force => {
                force.lifetime -= dt;
                if (force.lifetime <= 0) {
                    scene.remove(force.line);
                    scene.remove(force.cone);
                    return false;
                }
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ
                const opacity = force.lifetime / 2.0;
                if (force.line) {
                    force.line.material.opacity = opacity;
                }
                if (force.cone) {
                    force.cone.material.opacity = opacity;
                }
                return true;
            });
            
            // è¡çªç‚¹ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            wallImpacts = wallImpacts.filter(impact => {
                impact.lifetime -= dt;
                if (impact.lifetime <= 0) {
                    scene.remove(impact.mesh);
                    return false;
                }
                impact.mesh.material.opacity = impact.lifetime / 2.0 * 0.8;
                return true;
            });
            
            // åœ§åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã®æ›´æ–°ï¼ˆ0.5ç§’ã”ã¨ï¼‰
            if (showPressureVectors && frameCount % 30 === 0) {
                updatePressureVectors();
            }
        }
        
        function updatePressureVectors() {
            // æ—¢å­˜ã®åœ§åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã‚’å‰Šé™¤
            pressureVectors.forEach(vector => scene.remove(vector));
            pressureVectors = [];
            
            const halfBox = boxSize / 2;
            
            // å„é¢ã®åœ§åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½œæˆ
            Object.entries(wallImpulses).forEach(([wall, impulse]) => {
                if (impulse === 0) return; // åŠ›ç©ãŒã‚¼ãƒ­ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                
                const axis = wall[1];
                const sign = wall[0] === '+' ? 1 : -1;
                
                // ãƒ™ã‚¯ãƒˆãƒ«ã®ä½ç½®ï¼ˆé¢ã®ä¸­å¿ƒï¼‰
                const position = new THREE.Vector3(0, 0, 0);
                position[axis] = sign * halfBox;
                
                // ãƒ™ã‚¯ãƒˆãƒ«ã®æ–¹å‘ï¼ˆé¢ã®å¤–å´ã¸ï¼‰
                const direction = new THREE.Vector3(0, 0, 0);
                direction[axis] = sign;
                
                // åŠ›ç©ã‹ã‚‰å¹³å‡çš„ãªé€Ÿåº¦ã‚’æ¨å®š
                // 0.5ç§’é–“ã®ç´¯ç©åŠ›ç©ã‹ã‚‰ã€å¹³å‡çš„ãªè¡çªé€Ÿåº¦ã‚’é€†ç®—
                const collisionCount = Math.max(1, particleCount * 0.5 * 0.1); // æ¨å®šè¡çªå›æ•°
                const avgImpulsePerCollision = impulse / collisionCount;
                const avgSpeed = avgImpulsePerCollision / (2 * m_gas) * 1000; // m/s
                
                // é•·ã•ã‚’è¨ˆç®—ï¼ˆæœ€å°1.0ã€æœ€å¤§5.0ï¼‰
                const lengthRatio = Math.min(avgSpeed / 800, 1);
                const length = 1.0 + lengthRatio * 4.0;
                
                // è‰²ã‚’è¨ˆç®—ï¼ˆç²’å­ã¨åŒã˜è‰²åˆ†ã‘ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ï¼‰
                const color = getSpeedBasedColor(avgSpeed);
                
                // å¤ªã„ç·šã®ãŸã‚ã«ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚’ä½¿ç”¨
                const cylinderGeometry = new THREE.CylinderGeometry(0.15, 0.15, length, 8);
                const cylinderMaterial = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                
                // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ä½ç½®ã¨å‘ãã‚’è¨­å®š
                const cylinderPosition = position.clone().add(direction.clone().multiplyScalar(length / 2));
                cylinder.position.copy(cylinderPosition);
                
                // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚’æ–¹å‘ã«å‘ã‘ã‚‹
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, direction);
                cylinder.setRotationFromQuaternion(quaternion);
                
                // å¤§ãã‚ã®çŸ¢å°ã®å…ˆç«¯
                const coneSize = 0.5;
                const coneGeometry = new THREE.ConeGeometry(coneSize, coneSize * 2, 8);
                const coneMaterial = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                
                // ã‚³ãƒ¼ãƒ³ã®ä½ç½®ã‚’è¨­å®š
                const conePosition = position.clone().add(direction.clone().multiplyScalar(length - coneSize * 0.5));
                cone.position.copy(conePosition);
                
                // ã‚³ãƒ¼ãƒ³ã®å‘ãã‚’è¨­å®š
                cone.setRotationFromQuaternion(quaternion);
                
                scene.add(cylinder);
                scene.add(cone);
                pressureVectors.push(cylinder);
                pressureVectors.push(cone);
            });
            
            // åŠ›ç©ã‚’ãƒªã‚»ãƒƒãƒˆ
            Object.keys(wallImpulses).forEach(key => {
                wallImpulses[key] = 0;
            });
        }
        
        function updateParticleColor(particle) {
            const speed = particle.velocity.length() * 1000;
            // ç²’å­ã®è‰²åˆ†ã‘ã‚‚åŒã˜ç¯„å›²ã«èª¿æ•´
            // 0-750 m/s: é’â†’ç·‘
            // 750-1500 m/s: ç·‘â†’èµ¤
            const ratio = Math.min(speed / 1500, 1);
            
            let r, g, b;
            if (ratio < 0.5) {
                // é’â†’ç·‘
                r = 0;
                g = ratio * 2;
                b = 1 - ratio * 2;
            } else {
                // ç·‘â†’èµ¤
                r = (ratio - 0.5) * 2;
                g = 1 - (ratio - 0.5) * 2;
                b = 0;
            }
            
            particle.mesh.material.color.setRGB(r, g, b);
            particle.mesh.material.emissive.setRGB(r * 0.3, g * 0.3, b * 0.3);
        }
        
        function updateDistribution() {
            const canvas = document.getElementById('distribution-canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            // é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
            const speeds = particles.map(p => p.velocity.length() * 1000);
            
            // å›ºå®šã•ã‚ŒãŸæœ€å¤§é€Ÿåº¦ï¼ˆå¸¸ã«3000 m/sï¼‰
            const maxSpeed = 3000;
            
            // ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ä½œæˆ
            const bins = 30;
            const binWidth = maxSpeed / bins;
            const histogram = new Array(bins).fill(0);
            
            speeds.forEach(speed => {
                const bin = Math.floor(speed / binWidth);
                if (bin < bins) {
                    histogram[bin]++;
                }
            });
            
            // å›ºå®šã•ã‚ŒãŸç¸¦è»¸ã®æœ€å¤§å€¤ï¼ˆç²’å­æ•°ã®30%ï¼‰
            const fixedMaxCount = particleCount * 0.3;
            const barWidth = width / bins;
            
            // ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’æç”»
            histogram.forEach((count, i) => {
                const barHeight = Math.min((count / fixedMaxCount) * height * 0.85, height * 0.85);
                const speed = (i + 0.5) * binWidth;
                
                // é€Ÿåº¦ã«åŸºã¥ãè‰²ã‚’è¨ˆç®—ï¼ˆgetSpeedColorã‚’ä½¿ç”¨ï¼‰
                const color = getSpeedColor(speed);
                ctx.fillStyle = color;
                
                ctx.fillRect(
                    i * barWidth,
                    height - barHeight - 15,
                    barWidth - 1,
                    barHeight
                );
            });
            
            // è»¸ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#888';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // xè»¸ãƒ©ãƒ™ãƒ«ï¼ˆ0, 1000, 2000, 3000 m/sï¼‰
            for (let i = 0; i <= 3; i++) {
                const speed = i * 1000;
                const x = (speed / maxSpeed) * width;
                ctx.fillText(speed + ' m/s', x, height - 5);
            }
            
            // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
            updateStats(speeds);
        }
        
        // é€Ÿåº¦ã«åŸºã¥ã„ã¦è‰²ã‚’è¿”ã™é–¢æ•°
        function getSpeedColor(speed) {
            // æ¸©åº¦ã«ã‚ˆã‚‰ãšã€é€Ÿåº¦ã®çµ¶å¯¾å€¤ã§è‰²ã‚’æ±ºå®š
            // 0-750 m/s: é’â†’ç·‘
            // 750-1500 m/s: ç·‘â†’èµ¤
            const ratio = Math.min(speed / 1500, 1);
            
            let r, g, b;
            if (ratio < 0.5) {
                // é’â†’ç·‘
                r = 0;
                g = Math.floor(ratio * 2 * 255);
                b = Math.floor((1 - ratio * 2) * 255);
            } else {
                // ç·‘â†’èµ¤
                r = Math.floor((ratio - 0.5) * 2 * 255);
                g = Math.floor((1 - (ratio - 0.5) * 2) * 255);
                b = 0;
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function updateStats(speeds) {
            const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            const mostProbable = Math.sqrt(2 * k_B * temperature / m_gas);
            const avgEnergy = 0.5 * m_gas * avgSpeed * avgSpeed / 1e-21;
            
            // ç²’å­å¯†åº¦ã®è¨ˆç®—ã‚’ä¿®æ­£
            // boxSizeã®å˜ä½ã‚’nmã¨ã—ã¦æ‰±ã†ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å˜ä½ â†’ nmï¼‰
            const boxVolumeNm3 = boxSize * boxSize * boxSize; // nm^3
            const density = particleCount / boxVolumeNm3;
            
            document.getElementById('avg-speed').textContent = avgSpeed.toFixed(0);
            document.getElementById('most-probable-speed').textContent = mostProbable.toFixed(0);
            document.getElementById('avg-energy').textContent = avgEnergy.toFixed(2);
            document.getElementById('density').textContent = density.toFixed(3);
        }
        
        function setupMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            // ã‚¿ãƒƒãƒæ“ä½œã®ã‚µãƒãƒ¼ãƒˆ
            let touchStartDistance = 0;
            let touches = [];
            
            // ãƒã‚¦ã‚¹æ“ä½œ
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                rotateCamera(deltaX, deltaY);
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                zoomCamera(scale);
            });
            
            // ã‚¿ãƒƒãƒæ“ä½œ
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touches = Array.from(e.touches);
                
                if (touches.length === 1) {
                    // 1æœ¬æŒ‡ï¼šå›è»¢
                    mouseX = touches[0].clientX;
                    mouseY = touches[0].clientY;
                } else if (touches.length === 2) {
                    // 2æœ¬æŒ‡ï¼šãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const currentTouches = Array.from(e.touches);
                
                if (currentTouches.length === 1 && touches.length === 1) {
                    // 1æœ¬æŒ‡ï¼šå›è»¢
                    const deltaX = currentTouches[0].clientX - mouseX;
                    const deltaY = currentTouches[0].clientY - mouseY;
                    
                    rotateCamera(deltaX, deltaY);
                    
                    mouseX = currentTouches[0].clientX;
                    mouseY = currentTouches[0].clientY;
                } else if (currentTouches.length === 2 && touches.length === 2) {
                    // 2æœ¬æŒ‡ï¼šãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                    const dx = currentTouches[0].clientX - currentTouches[1].clientX;
                    const dy = currentTouches[0].clientY - currentTouches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (touchStartDistance > 0) {
                        const scale = touchStartDistance / currentDistance;
                        zoomCamera(scale);
                        touchStartDistance = currentDistance;
                    }
                }
                
                touches = currentTouches;
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', (e) => {
                touches = Array.from(e.touches);
                if (touches.length === 0) {
                    touchStartDistance = 0;
                }
            });
            
            // ã‚«ãƒ¡ãƒ©å›è»¢é–¢æ•°
            function rotateCamera(deltaX, deltaY) {
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                // å·¦å³ã®å›è»¢ã¯åè»¢ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªæ“ä½œæ„Ÿï¼‰
                spherical.theta += deltaX * 0.01;
                // ä¸Šä¸‹ã®å›è»¢ã¯ãã®ã¾ã¾
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }
            
            // ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ é–¢æ•°
            function zoomCamera(scale) {
                const radius = camera.position.length();
                const newRadius = Math.max(10, Math.min(50, radius * scale));
                camera.position.normalize().multiplyScalar(newRadius);
                camera.lookAt(0, 0, 0);
            }
        }
        
        function setupEventListeners() {
            // ç²’å­æ•°
            document.getElementById('particles').addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
                document.getElementById('particle-count').textContent = particleCount;
                createParticles();
            });
            
            // æ¸©åº¦
            document.getElementById('temperature').addEventListener('input', (e) => {
                temperature = parseInt(e.target.value);
                document.getElementById('temperature-value').textContent = temperature;
                particles.forEach(p => {
                    p.velocity = generateVelocity();
                });
            });
            
            // æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«
            document.getElementById('time-scale').addEventListener('input', (e) => {
                timeScale = parseFloat(e.target.value);
                document.getElementById('time-scale-value').textContent = timeScale.toFixed(1);
            });
            
            // ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('reset-btn').addEventListener('click', () => {
                createParticles();
            });
            
            // ä¸€æ™‚åœæ­¢
            document.getElementById('pause-btn').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('pause-btn').textContent = 
                    isPaused ? 'å†ç”Ÿ' : 'ä¸€æ™‚åœæ­¢';
            });
            
            // åŠ›ã®å¯è¦–åŒ–ã‚ªãƒ—ã‚·ãƒ§ãƒ³
            document.getElementById('show-wall-forces').addEventListener('change', (e) => {
                showWallForces = e.target.checked;
                if (!showWallForces) {
                    // æ—¢å­˜ã®åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã‚’å‰Šé™¤
                    wallForces.forEach(force => {
                        scene.remove(force.line);
                        scene.remove(force.cone);
                    });
                    wallForces = [];
                    wallImpacts.forEach(impact => scene.remove(impact.mesh));
                    wallImpacts = [];
                }
            });
            
            document.getElementById('show-pressure-vectors').addEventListener('change', (e) => {
                showPressureVectors = e.target.checked;
                if (!showPressureVectors) {
                    // æ—¢å­˜ã®åœ§åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã‚’å‰Šé™¤
                    pressureVectors.forEach(vector => scene.remove(vector));
                    pressureVectors = [];
                    // åŠ›ç©ã‚’ãƒªã‚»ãƒƒãƒˆ
                    Object.keys(wallImpulses).forEach(key => {
                        wallImpulses[key] = 0;
                    });
                }
            });
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // ãƒ¢ãƒã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileInfoBtn = document.getElementById('mobile-info-btn');
            const controls = document.getElementById('controls');
            const infoPanel = document.getElementById('info-panel');
            
            if (mobileMenuBtn) {
                mobileMenuBtn.addEventListener('click', () => {
                    controls.classList.toggle('show');
                    infoPanel.classList.remove('show');
                });
            }
            
            if (mobileInfoBtn) {
                mobileInfoBtn.addEventListener('click', () => {
                    infoPanel.classList.toggle('show');
                    controls.classList.remove('show');
                });
            }
            
            // ãƒ¢ãƒã‚¤ãƒ«ã§ãƒ‘ãƒãƒ«ã®å¤–ã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‚‰é–‰ã˜ã‚‹
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768) {
                    if (!controls.contains(e.target) && e.target !== mobileMenuBtn) {
                        controls.classList.remove('show');
                    }
                    if (!infoPanel.contains(e.target) && e.target !== mobileInfoBtn) {
                        infoPanel.classList.remove('show');
                    }
                }
            });
        }
        
        let lastTime = 0;
        let frameCount = 0;
        
        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            
            const deltaTime = Math.min((currentTime - lastTime) * 0.001, 0.1);
            lastTime = currentTime;
            
            updateParticles(deltaTime);
            
            // 10ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«åˆ†å¸ƒã‚’æ›´æ–°
            frameCount++;
            if (frameCount % 10 === 0) {
                updateDistribution();
            }
            
            renderer.render(scene, camera);
        }
        
        // é–‹å§‹
        init();
    </script>
</body>
</html>
